/**
 * Mock Generator - Generates mock files for server actions
 * 
 * This module creates TypeScript mock files that replace actual server action
 * implementations during preview mode.
 */

import fs from 'fs/promises';
import path from 'path';
import { ServerActionFile } from './scanner.js';

// Logging utility
const log = {
  info: (msg: string, data?: any) => {
    console.log(`\x1b[34m[MOCK-GEN]\x1b[0m ${msg}`, data !== undefined ? data : '');
  },
  success: (msg: string, data?: any) => {
    console.log(`\x1b[32m[MOCK-GEN ‚úì]\x1b[0m ${msg}`, data !== undefined ? data : '');
  },
  warn: (msg: string, data?: any) => {
    console.log(`\x1b[33m[MOCK-GEN ‚ö†]\x1b[0m ${msg}`, data !== undefined ? data : '');
  },
  error: (msg: string, data?: any) => {
    console.log(`\x1b[31m[MOCK-GEN ‚úó]\x1b[0m ${msg}`, data !== undefined ? data : '');
  },
  debug: (msg: string, data?: any) => {
    console.log(`\x1b[90m[MOCK-GEN üîç]\x1b[0m ${msg}`, data !== undefined ? data : '');
  }
};

export interface MockServerAction {
  functionName: string;
  returns: any;
  // Optional: simulate errors
  throwError?: string;
  // Optional: delay in ms to simulate network latency
  delay?: number;
}

export interface MockServerActionsConfig {
  [importPath: string]: {
    [functionName: string]: MockServerAction;
  };
}

/**
 * Generate a mock file for a server action file
 * Includes 'use server' directive for Next.js server action compatibility
 */
export function generateMockFileContent(
  originalPath: string,
  mocks: Record<string, { returns: any; throwError?: string; delay?: number }>
): string {
  // Must include 'use server' directive for Next.js to treat these as server actions
  const header = `'use server';

/**
 * Auto-generated by Explorer for Server Action Mocking
 * Original file: ${originalPath}
 * 
 * DO NOT EDIT - This file is auto-generated during preview setup
 * To update mocks, modify your story file's mockServerActions section
 */

`;

  const functions = Object.entries(mocks).map(([fnName, config]) => {
    const returnValue = JSON.stringify(config.returns, null, 2);
    const delayCode = config.delay ? `
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, ${config.delay}));` : '';
    
    const errorCode = config.throwError ? `
  // Simulate error
  throw new Error(${JSON.stringify(config.throwError)});` : '';
    
    return `
export async function ${fnName}(...args: any[]): Promise<any> {
  console.log('[Explorer Mock] ${fnName} called with:', args);${delayCode}${errorCode}
  
  return ${returnValue};
}`;
  }).join('\n');

  return header + functions;
}

/**
 * Generate mock files from a story's mockServerActions configuration
 * 
 * IMPORTANT: For Next.js with Turbopack, mocks are placed at __storial_mocks__/
 * at the project root. This allows them to be resolved via @/ alias:
 * @/components/cart/actions ‚Üí @/__storial_mocks__/components/cart/actions.mock
 * 
 * The mock file must export ALL functions from the original file, not just
 * the ones specified in mockServerActions. Otherwise, other imports will fail.
 */
export async function generateMockFiles(
  projectPath: string,
  mockServerActions: MockServerActionsConfig
): Promise<{ created: string[]; errors: string[] }> {
  const created: string[] = [];
  const errors: string[] = [];
  
  // Use __storial_mocks__ at project root (covered by @/ alias)
  const mocksDir = path.join(projectPath, '__storial_mocks__');
  
  for (const [importPath, functionMocks] of Object.entries(mockServerActions)) {
    try {
      // Convert import path to mock file path
      // e.g., "components/cart/actions" -> "__storial_mocks__/components/cart/actions.mock.ts"
      const cleanPath = importPath
        .replace(/^[@~]\//, '') // Remove @ or ~ prefix
        .replace(/^\.\//, '')   // Remove ./ prefix
        .replace(/\.(ts|tsx|js|jsx)$/, ''); // Remove extension if present
      
      const mockFilePath = path.join(mocksDir, `${cleanPath}.mock.ts`);
      
      // Ensure directory exists
      const mockFileDir = path.dirname(mockFilePath);
      await fs.mkdir(mockFileDir, { recursive: true });
      
      // Try to find and scan the original file for ALL exports
      const originalFilePath = await findOriginalFile(projectPath, cleanPath);
      let allExports: string[] = [];
      
      if (originalFilePath) {
        allExports = await scanFileExports(originalFilePath);
        log.debug(`Found ${allExports.length} exports in original file:`, allExports);
      }
      
      // Transform function mocks to the format expected by generateMockFileContent
      const mocksConfig: Record<string, { returns: any; throwError?: string; delay?: number }> = {};
      
      // First, add all exports from the original file as stubs
      for (const exportName of allExports) {
        mocksConfig[exportName] = { returns: null };
      }
      
      // Then, override with any specific mocks from the story
      for (const [fnName, mock] of Object.entries(functionMocks)) {
        mocksConfig[fnName] = {
          returns: mock.returns,
          throwError: mock.throwError,
          delay: mock.delay,
        };
      }
      
      const content = generateMockFileContent(importPath, mocksConfig);
      await fs.writeFile(mockFilePath, content, 'utf-8');
      
      created.push(mockFilePath);
      log.success(`Created mock file: ${path.relative(projectPath, mockFilePath)} with ${Object.keys(mocksConfig).length} exports`);
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : String(error);
      errors.push(`Failed to create mock for ${importPath}: ${errMsg}`);
      log.error(`Failed to create mock for ${importPath}`, error);
    }
  }
  
  return { created, errors };
}

/**
 * Find the original file path for a given import path
 */
async function findOriginalFile(projectPath: string, importPath: string): Promise<string | null> {
  const extensions = ['.ts', '.tsx', '.js', '.jsx'];
  
  for (const ext of extensions) {
    const filePath = path.join(projectPath, importPath + ext);
    try {
      await fs.access(filePath);
      return filePath;
    } catch {
      continue;
    }
  }
  
  // Also try index files
  for (const ext of extensions) {
    const filePath = path.join(projectPath, importPath, 'index' + ext);
    try {
      await fs.access(filePath);
      return filePath;
    } catch {
      continue;
    }
  }
  
  return null;
}

/**
 * Scan a TypeScript/JavaScript file for exported function names
 */
async function scanFileExports(filePath: string): Promise<string[]> {
  const exports: string[] = [];
  
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    
    // Match: export async function name(
    // Match: export function name(
    // Match: export const name =
    const exportPatterns = [
      /export\s+async\s+function\s+(\w+)\s*\(/g,
      /export\s+function\s+(\w+)\s*\(/g,
      /export\s+const\s+(\w+)\s*=/g,
      /export\s+let\s+(\w+)\s*=/g,
    ];
    
    for (const pattern of exportPatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        if (!exports.includes(match[1])) {
          exports.push(match[1]);
        }
      }
    }
  } catch (error) {
    log.warn(`Failed to scan exports from ${filePath}:`, error);
  }
  
  return exports;
}

/**
 * Get the relative path for a mock file based on import path
 * Returns path relative to project root, using __storial_mocks__/
 */
export function getMockFilePath(importPath: string): string {
  const cleanPath = importPath
    .replace(/^[@~]\//, '')
    .replace(/^\.\//, '')
    .replace(/\.(ts|tsx|js|jsx)$/, '');
  
  return `__storial_mocks__/${cleanPath}.mock`;
}

/**
 * Generate a mapping of original import paths to mock file paths
 * Used by build config injector
 */
export function generateMockAliases(
  projectPath: string,
  mockServerActions: MockServerActionsConfig
): Record<string, string> {
  const aliases: Record<string, string> = {};
  
  for (const importPath of Object.keys(mockServerActions)) {
    const mockPath = getMockFilePath(importPath);
    
    // Convert to absolute path relative to project
    const absoluteMockPath = path.join(projectPath, mockPath);
    
    aliases[importPath] = absoluteMockPath;
  }
  
  return aliases;
}

/**
 * Clean up all generated mock files
 */
export async function cleanupMockFiles(projectPath: string): Promise<void> {
  const mocksDir = path.join(projectPath, '__storial_mocks__');
  
  try {
    await fs.rm(mocksDir, { recursive: true, force: true });
    log.success('Cleaned up mock files');
  } catch (error) {
    log.warn('Failed to clean up mock files', error);
  }
  
  // Also clean up old .storial/mocks location if it exists
  const oldMocksDir = path.join(projectPath, '.storial', 'mocks');
  try {
    await fs.rm(oldMocksDir, { recursive: true, force: true });
  } catch {
    // Old directory doesn't exist, that's fine
  }
}

/**
 * List all existing mock files in the project
 */
export async function listMockFiles(projectPath: string): Promise<string[]> {
  const mocksDir = path.join(projectPath, '__storial_mocks__');
  const mockFiles: string[] = [];
  
  try {
    const findMocks = async (dir: string): Promise<void> => {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          await findMocks(fullPath);
        } else if (entry.name.endsWith('.mock.ts') || entry.name.endsWith('.mock.js')) {
          mockFiles.push(fullPath);
        }
      }
    };
    
    await fs.access(mocksDir);
    await findMocks(mocksDir);
  } catch {
    // Directory doesn't exist or can't be accessed
  }
  
  return mockFiles;
}

