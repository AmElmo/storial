/**
 * Preview Injector
 * 
 * Creates the preview infrastructure in the target project:
 * 1. __Canvas.tsx - The preview route component for components and pages
 * 2. Component registry - Maps component names to import paths
 * 3. Route registration - Adds preview route to the app
 */

import fs from 'fs/promises';
import path from 'path';
import type { ComponentInfo, RouterType } from './scanner.js';

// Logging
const log = {
  info: (msg: string, data?: any) => {
    console.log(`\x1b[36m[PREVIEW-INJECTOR]\x1b[0m ${msg}`, data !== undefined ? data : '');
  },
  success: (msg: string, data?: any) => {
    console.log(`\x1b[32m[PREVIEW-INJECTOR ✓]\x1b[0m ${msg}`, data !== undefined ? data : '');
  },
  error: (msg: string, data?: any) => {
    console.log(`\x1b[31m[PREVIEW-INJECTOR ✗]\x1b[0m ${msg}`, data !== undefined ? data : '');
  },
  warn: (msg: string, data?: any) => {
    console.log(`\x1b[33m[PREVIEW-INJECTOR ⚠]\x1b[0m ${msg}`, data !== undefined ? data : '');
  }
};

// ==================== PREVIEW COMPONENT TEMPLATE ====================

/**
 * Analyzes component paths to find unique directories for glob patterns
 */
function detectComponentDirectories(components: ComponentInfo[]): string[] {
  const directories = new Set<string>();
  
  for (const comp of components) {
    // Find the path after /src/
    const srcIndex = comp.filePath.lastIndexOf('/src/');
    if (srcIndex === -1) continue;
    
    const relativePath = comp.filePath.slice(srcIndex); // e.g., /src/components/ui/button.tsx
    
    // Extract the directory pattern (e.g., /src/components)
    const parts = relativePath.split('/').filter(Boolean); // ['src', 'components', 'ui', 'button.tsx']
    
    if (parts.length >= 2) {
      // Take the first two levels: /src/components, /src/ui, etc.
      const baseDir = '/' + parts.slice(0, 2).join('/');
      directories.add(baseDir);
      
      // If there's a deeper structure like /src/components/ui, add that too
      if (parts.length >= 3 && !parts[2].includes('.')) {
        const deeperDir = '/' + parts.slice(0, 3).join('/');
        directories.add(deeperDir);
      }
    }
  }
  
  return Array.from(directories);
}

/**
 * Generates glob patterns from detected directories
 */
function generateGlobPatterns(directories: string[]): string[] {
  const patterns: string[] = [];
  
  for (const dir of directories) {
    patterns.push(`'${dir}/**/*.tsx'`);
    patterns.push(`'${dir}/**/*.ts'`);
  }
  
  // Add fallback patterns for common locations
  const commonPatterns = [
    "'/src/components/**/*.tsx'",
    "'/src/components/**/*.ts'",
    "'/components/**/*.tsx'",
    "'/components/**/*.ts'"
  ];
  
  // Add common patterns if not already covered
  for (const pattern of commonPatterns) {
    if (!patterns.includes(pattern)) {
      patterns.push(pattern);
    }
  }
  
  return [...new Set(patterns)]; // Remove duplicates
}

function generatePreviewComponent(components: ComponentInfo[], explorerPort: number): string {
  // Detect component directories and generate glob patterns
  const directories = detectComponentDirectories(components);
  const globPatterns = generateGlobPatterns(directories);
  
  log.info('Detected component directories:', directories);
  log.info('Generated glob patterns:', globPatterns);

  // Join glob patterns for the template
  const globPatternsString = globPatterns.join(',\n    ');

  return `/**
 * Canvas - Auto-generated by Explorer
 * 
 * This file enables isolated component/page preview with mock data.
 * DO NOT EDIT - This file is managed by the Explorer tool.
 * 
 * Generated glob patterns based on your project structure:
 * ${directories.join(', ')}
 * 
 * ⚠️ BUILD WARNINGS NOTE:
 * During production builds, you may see warnings like:
 *   "X is dynamically imported by __Canvas.tsx but also statically imported..."
 * 
 * These warnings are EXPECTED and HARMLESS. They occur because Canvas uses
 * import.meta.glob() to dynamically load components for preview, while the
 * same components are statically imported elsewhere in your app.
 * 
 * The build succeeds normally. Canvas is a dev-only tool and returns null
 * in production, so these dynamic imports are tree-shaken from your bundle.
 * 
 * To suppress these warnings, see:
 * https://github.com/your-repo/nextjs-explorer#suppressing-build-warnings
 */
'use client';

import React, { useState, useEffect, Suspense, Component, type ReactNode, type ErrorInfo } from 'react';
import { useSearchParams } from 'react-router-dom';
import * as ReactRouterDOM from 'react-router-dom';

// Explorer server URL
const EXPLORER_SERVER = 'http://localhost:${explorerPort}';

// ==================== RESILIENT ROUTER DETECTION ====================
// Detect React Router version and available contexts for route params injection
// Supports v5, v6, and gracefully degrades for unknown versions

type RouterCapabilities = {
  version: 'v6' | 'v5' | 'unknown';
  hasUnsafeContexts: boolean;
  RouteContext: React.Context<any> | null;
  LocationContext: React.Context<any> | null;
  DataRouterContext: React.Context<any> | null;
};

function detectRouterCapabilities(): RouterCapabilities {
  const rr = ReactRouterDOM as any;
  
  // Check for React Router v6 UNSAFE_* contexts
  if (rr.UNSAFE_RouteContext && rr.UNSAFE_LocationContext) {
    console.log('[Canvas] React Router v6 detected with UNSAFE contexts');
    return {
      version: 'v6',
      hasUnsafeContexts: true,
      RouteContext: rr.UNSAFE_RouteContext,
      LocationContext: rr.UNSAFE_LocationContext,
      DataRouterContext: rr.UNSAFE_DataRouterContext || null
    };
  }
  
  // Check for React Router v5 __RouterContext
  if (rr.__RouterContext) {
    console.log('[Canvas] React Router v5 detected');
    return {
      version: 'v5',
      hasUnsafeContexts: false,
      RouteContext: rr.__RouterContext,
      LocationContext: null,
      DataRouterContext: null
    };
  }
  
  console.warn('[Canvas] Could not detect React Router version - route params injection may not work');
  return {
    version: 'unknown',
    hasUnsafeContexts: false,
    RouteContext: null,
    LocationContext: null,
    DataRouterContext: null
  };
}

const routerCapabilities = detectRouterCapabilities();

// ==================== ERROR BOUNDARY ====================
// Catches errors in route params injection and falls back to rendering without params
interface ErrorBoundaryState { hasError: boolean; error: Error | null; }

class RouteParamsErrorBoundary extends Component<
  { children: ReactNode; fallback: ReactNode },
  ErrorBoundaryState
> {
  constructor(props: { children: ReactNode; fallback: ReactNode }) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, _errorInfo: ErrorInfo) {
    console.warn('[Canvas] Route params injection failed, rendering without params:', error.message);
  }

  render() {
    if (this.state.hasError) return this.props.fallback;
    return this.props.children;
  }
}

// ==================== DYNAMIC COMPONENT LOADING ====================
// Using import.meta.glob with patterns detected from your project structure
const modules = import.meta.glob([
    ${globPatternsString}
]);

console.log('[Canvas] Available modules:', Object.keys(modules).length);

// ==================== FETCH MOCKING ====================
interface MockApiConfig {
  [endpoint: string]: any;
}

let originalFetch: typeof fetch;
let mockApiConfig: MockApiConfig = {};

function setupFetchMocking(mockApi: MockApiConfig) {
  mockApiConfig = mockApi;
  
  if (!originalFetch) {
    originalFetch = window.fetch;
  }
  
  window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
    const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
    const method = init?.method?.toUpperCase() || 'GET';
    
    // Check if this endpoint should be mocked
    for (const [endpoint, mockData] of Object.entries(mockApiConfig)) {
      // Parse endpoint pattern (e.g., "GET /api/users" or just "/api/users")
      const [mockMethod, mockPath] = endpoint.includes(' ') 
        ? endpoint.split(' ') 
        : ['GET', endpoint];
      
      // Check if URL matches the mock pattern
      if (url.includes(mockPath) && method === mockMethod.toUpperCase()) {
        console.log('[Canvas] Mocking API:', method, url, '→', mockData);
        
        // Handle special mock directives
        if (mockData?.__delay) {
          // Simulate infinite loading
          return new Promise(() => {});
        }
        
        if (mockData?.__error) {
          return new Response(JSON.stringify(mockData.__error), {
            status: mockData.__error.status || 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
        
        // Return mock data
        return new Response(JSON.stringify(mockData), {
          status: 200,
          headers: { 'Content-Type': 'application/json' }
        });
      }
    }
    
    // Not mocked, use original fetch
    return originalFetch(input, init);
  };
}

function cleanupFetchMocking() {
  if (originalFetch) {
    window.fetch = originalFetch;
  }
  mockApiConfig = {};
}

// ==================== STORY FETCHING ====================
interface Story {
  id: string;
  name: string;
  description?: string;
  props?: Record<string, any>;
  routeParams?: Record<string, string>;
  mockApi?: MockApiConfig;
  mockContext?: Record<string, any>;
}

interface StoriesFile {
  componentName?: string;
  pageName?: string;
  pageRoute?: string;
  type: 'component' | 'page';
  stories: Story[];
}

interface StoryData {
  story: Story | null;
  pageRoute: string | null;
  error: string | null;
}

async function fetchStoryData(
  type: 'component' | 'page',
  name: string,
  storyId: string
): Promise<StoryData> {
  try {
    const response = await fetch(
      \`\${EXPLORER_SERVER}/api/stories/\${type}/\${encodeURIComponent(name)}\`
    );
    
    if (!response.ok) {
      return { story: null, pageRoute: null, error: 'No stories found' };
    }
    
    const storiesFile: StoriesFile = await response.json();
    const story = storiesFile.stories.find(s => s.id === storyId) || storiesFile.stories[0];
    
    return { story, pageRoute: storiesFile.pageRoute || null, error: null };
  } catch (error) {
    console.error('[Canvas] Failed to fetch story:', error);
    return { story: null, pageRoute: null, error: 'Failed to connect to Explorer server' };
  }
}

// ==================== ROUTE PARAMS HELPER ====================
// Build the actual URL from a route pattern and params
// e.g., "/specification/:projectId" + { projectId: "my-app" } => "/specification/my-app"
function buildRouteUrl(routePattern: string, params: Record<string, string>): string {
  let url = routePattern;
  for (const [key, value] of Object.entries(params)) {
    url = url.replace(\`:$\{key}\`, value);
  }
  return url;
}

// ==================== ROUTE PARAMS PROVIDER ====================
// Provides route params via React Router's internal contexts WITHOUT creating a new router
// Supports React Router v5, v6, and gracefully degrades for unknown versions
interface RouteParamsProviderProps {
  pageRoute: string;
  routeParams: Record<string, string>;
  children: React.ReactNode;
}

function RouteParamsProviderV6({ pageRoute, routeParams, children }: RouteParamsProviderProps) {
  const pathname = buildRouteUrl(pageRoute, routeParams);
  const { RouteContext, LocationContext, DataRouterContext } = routerCapabilities;
  
  if (!RouteContext || !LocationContext) {
    console.warn('[Canvas] V6 contexts not available, rendering without params');
    return <>{children}</>;
  }
  
  const location = { pathname, search: '', hash: '', state: null, key: 'preview' };
  const routeContext = {
    outlet: null,
    matches: [{ params: routeParams, pathname, pathnameBase: pathname, route: { path: pageRoute } }],
    isDataRoute: false
  };
  const locationContext = { location, navigationType: 'POP' };
  
  let element = (
    <LocationContext.Provider value={locationContext}>
      <RouteContext.Provider value={routeContext}>{children}</RouteContext.Provider>
    </LocationContext.Provider>
  );
  
  if (DataRouterContext) {
    element = <DataRouterContext.Provider value={null}>{element}</DataRouterContext.Provider>;
  }
  
  return element;
}

function RouteParamsProviderV5({ pageRoute, routeParams, children }: RouteParamsProviderProps) {
  const pathname = buildRouteUrl(pageRoute, routeParams);
  const { RouteContext } = routerCapabilities;
  
  if (!RouteContext) {
    console.warn('[Canvas] V5 RouterContext not available, rendering without params');
    return <>{children}</>;
  }
  
  const contextValue = {
    match: { params: routeParams, isExact: true, path: pageRoute, url: pathname },
    location: { pathname, search: '', hash: '', state: null, key: 'preview' },
    history: {
      length: 1, action: 'POP',
      location: { pathname, search: '', hash: '', state: null, key: 'preview' },
      push: () => console.warn('[Canvas] Navigation disabled in preview'),
      replace: () => console.warn('[Canvas] Navigation disabled in preview'),
      go: () => {}, goBack: () => {}, goForward: () => {},
      block: () => () => {}, listen: () => () => {},
      createHref: (loc: any) => typeof loc === 'string' ? loc : loc.pathname || ''
    }
  };
  
  return <RouteContext.Provider value={contextValue}>{children}</RouteContext.Provider>;
}

function RouteParamsProvider({ pageRoute, routeParams, children }: RouteParamsProviderProps) {
  const pathname = buildRouteUrl(pageRoute, routeParams);
  console.log('[Canvas] RouteParamsProvider:', { pageRoute, routeParams, pathname, routerVersion: routerCapabilities.version });
  
  if (routerCapabilities.version === 'v6') {
    return <RouteParamsProviderV6 pageRoute={pageRoute} routeParams={routeParams}>{children}</RouteParamsProviderV6>;
  }
  
  if (routerCapabilities.version === 'v5') {
    return <RouteParamsProviderV5 pageRoute={pageRoute} routeParams={routeParams}>{children}</RouteParamsProviderV5>;
  }
  
  console.warn('[Canvas] Unknown router version, rendering without route params injection');
  return <>{children}</>;
}

// ==================== DYNAMIC COMPONENT LOADER ====================
interface DynamicComponentProps {
  componentName: string;
  props: Record<string, any>;
  routeParams?: Record<string, string>;
  pageRoute?: string | null;
}

// Helper to convert string to PascalCase
function toPascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Helper to normalize names (removes hyphens/underscores, lowercases)
// This handles kebab-case filenames matching PascalCase imports
// e.g., "user-name-form" -> "usernameform" and "UserNameForm" -> "usernameform"
function normalizeForMatch(str: string): string {
  return str.replace(/[-_]/g, '').toLowerCase();
}

// Find a module that matches the component name
async function findAndLoadModule(componentName: string): Promise<any> {
  const lowerName = componentName.toLowerCase();
  const pascalName = toPascalCase(componentName);
  const normalizedName = normalizeForMatch(componentName);
  
  // Search through all available modules
  for (const [modulePath, loader] of Object.entries(modules)) {
    // Extract filename from path (e.g., '/src/components/ui/button.tsx' -> 'button')
    const fileName = modulePath.split('/').pop()?.replace(/\\.(tsx?|jsx?)$/, '') || '';
    const fileNameLower = fileName.toLowerCase();
    const fileNameNormalized = normalizeForMatch(fileName);
    
    // Match by filename - try multiple strategies:
    // 1. Exact match
    // 2. Case-insensitive match
    // 3. Normalized match (handles kebab-case <-> PascalCase)
    if (fileName === componentName || 
        fileName === pascalName || 
        fileNameLower === lowerName || 
        fileNameNormalized === normalizedName) {
      console.log('[Canvas] Found module for', componentName, ':', modulePath);
      return await (loader as () => Promise<any>)();
    }
  }
  
  // If no exact filename match, try path contains (normalized)
  for (const [modulePath, loader] of Object.entries(modules)) {
    const pathNormalized = normalizeForMatch(modulePath);
    if (pathNormalized.includes('/' + normalizedName + '.') ||
        pathNormalized.includes('/' + normalizedName + '/')) {
      console.log('[Canvas] Found module (path match) for', componentName, ':', modulePath);
      return await (loader as () => Promise<any>)();
    }
  }
  
  console.error('[Canvas] No module found for:', componentName);
  console.error('[Canvas] Available modules:', Object.keys(modules).slice(0, 15), '...');
  return null;
}

function DynamicComponent({ componentName, props, routeParams, pageRoute }: DynamicComponentProps) {
  const [Component, setComponent] = useState<React.ComponentType<any> | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadComponent = async () => {
      try {
        const module = await findAndLoadModule(componentName);
        
        if (!module) {
          setError(\`Component "\${componentName}" not found. Available modules: \${Object.keys(modules).length}\`);
          return;
        }
        
        // Try multiple variations to find the component export
        const pascalName = toPascalCase(componentName);
        const Comp = module[componentName] || module[pascalName] || module.default;
        
        if (!Comp) {
          console.error('[Canvas] Available exports:', Object.keys(module));
          setError(\`Component "\${componentName}" not exported. Available: \${Object.keys(module).join(', ')}\`);
          return;
        }
        
        console.log('[Canvas] Loaded component:', componentName);
        setComponent(() => Comp);
      } catch (err) {
        console.error('[Canvas] Failed to load component:', err);
        setError(\`Failed to load component: \${err}\`);
      }
    };
    
    loadComponent();
  }, [componentName]);

  if (error) {
    return (
      <div style={{ padding: 20, color: 'red', fontFamily: 'monospace' }}>
        <strong>Error:</strong> {error}
      </div>
    );
  }

  if (!Component) {
    return (
      <div style={{ padding: 20, color: '#666' }}>
        Loading component...
      </div>
    );
  }

  // If we have routeParams and a pageRoute, provide them via React Router's internal contexts
  // This makes useParams() return the mock params without creating a nested router
  // Wrapped in error boundary for resilience - if injection fails, falls back to rendering without params
  const hasRouteParams = routeParams && pageRoute && Object.keys(routeParams).length > 0;
  
  if (hasRouteParams && pageRoute) {
    const componentWithoutParams = <Component {...props} />;
    
    return (
      <RouteParamsErrorBoundary fallback={componentWithoutParams}>
        <RouteParamsProvider pageRoute={pageRoute} routeParams={routeParams!}>
          <Component {...props} />
        </RouteParamsProvider>
      </RouteParamsErrorBoundary>
    );
  }

  return <Component {...props} />;
}

// ==================== MAIN PREVIEW COMPONENT ====================
export default function Canvas() {
  const [searchParams] = useSearchParams();
  const componentName = searchParams.get('component') || '';
  const pageName = searchParams.get('page') || '';
  const storyId = searchParams.get('story') || 'default';
  
  // Determine if we're previewing a component or page
  const isPage = !!pageName;
  const itemName = pageName || componentName;
  const itemType = isPage ? 'page' : 'component';
  
  const [story, setStory] = useState<Story | null>(null);
  const [pageRoute, setPageRoute] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadStory = async () => {
      setLoading(true);
      setError(null);
      
      if (!itemName) {
        setError('No component or page specified. Use ?component=Name or ?page=Name');
        setLoading(false);
        return;
      }
      
      console.log('[Canvas] Loading', { itemType, itemName, storyId });
      
      // Fetch story data from Explorer
      const storyData = await fetchStoryData(
        itemType,
        itemName,
        storyId
      );
      
      if (storyData.error) {
        setError(storyData.error);
        setLoading(false);
        return;
      }
      
      if (storyData.story) {
        setStory(storyData.story);
        setPageRoute(storyData.pageRoute);
        
        // Log route params info for debugging
        if (storyData.story.routeParams && Object.keys(storyData.story.routeParams).length > 0) {
          console.log('[Canvas] Story has routeParams:', storyData.story.routeParams);
          console.log('[Canvas] Page route:', storyData.pageRoute);
        }
        
        // Setup fetch mocking if story has mockApi
        if (storyData.story.mockApi && Object.keys(storyData.story.mockApi).length > 0) {
          console.log('[Canvas] Setting up fetch mocking for:', Object.keys(storyData.story.mockApi));
          setupFetchMocking(storyData.story.mockApi);
        }
      }
      
      setLoading(false);
    };
    
    loadStory();
    
    // Cleanup on unmount
    return () => {
      cleanupFetchMocking();
    };
  }, [itemName, itemType, storyId]);

  // Loading state
  if (loading) {
    return (
      <div style={{ 
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center', 
        height: '100vh',
        fontFamily: 'system-ui, sans-serif',
        color: '#666'
      }}>
        <div style={{ textAlign: 'center' }}>
          <div style={{ marginBottom: 8 }}>Loading preview...</div>
          <div style={{ fontSize: 12, opacity: 0.7 }}>
            {itemType}: {itemName} / {storyId}
          </div>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div style={{ 
        padding: 20, 
        fontFamily: 'system-ui, sans-serif'
      }}>
        <div style={{ 
          padding: 16, 
          background: '#fef2f2', 
          border: '1px solid #fecaca',
          borderRadius: 8,
          color: '#991b1b'
        }}>
          <strong>Preview Error</strong>
          <div style={{ marginTop: 8, fontSize: 14 }}>{error}</div>
          <div style={{ marginTop: 12, fontSize: 12, opacity: 0.7 }}>
            {itemType}: {itemName}<br />
            Story: {storyId}
          </div>
        </div>
      </div>
    );
  }

  // No story found
  if (!story) {
    return (
      <div style={{ 
        padding: 20, 
        fontFamily: 'system-ui, sans-serif'
      }}>
        <div style={{ 
          padding: 16, 
          background: '#fefce8', 
          border: '1px solid #fef08a',
          borderRadius: 8,
          color: '#854d0e'
        }}>
          <strong>No Story Found</strong>
          <div style={{ marginTop: 8, fontSize: 14 }}>
            Generate stories for this {itemType} using the Explorer.
          </div>
        </div>
      </div>
    );
  }

  // Render component/page with story props
  const props = story.props || {};

  return (
    <div style={{ padding: 20 }}>
      {/* Story Info Header */}
      <div style={{ 
        marginBottom: 16, 
        paddingBottom: 16, 
        borderBottom: '1px solid #e5e7eb',
        fontFamily: 'system-ui, sans-serif'
      }}>
        <div style={{ 
          fontSize: 12, 
          color: '#6b7280',
          marginBottom: 4 
        }}>
          <span style={{ 
            padding: '2px 6px', 
            background: isPage ? '#dbeafe' : '#f3e8ff',
            color: isPage ? '#1d4ed8' : '#7c3aed',
            borderRadius: 4,
            fontSize: 10,
            marginRight: 8,
            textTransform: 'uppercase'
          }}>
            {itemType}
          </span>
          {itemName}
        </div>
        <div style={{ 
          fontSize: 16, 
          fontWeight: 600,
          color: '#111827'
        }}>
          {story.name}
        </div>
        {story.description && (
          <div style={{ 
            fontSize: 13, 
            color: '#6b7280',
            marginTop: 4 
          }}>
            {story.description}
          </div>
        )}
      </div>

      {/* Component/Page Render */}
      <Suspense fallback={<div>Loading...</div>}>
        <DynamicComponent 
          componentName={itemName} 
          props={props} 
          routeParams={story.routeParams}
          pageRoute={pageRoute}
        />
      </Suspense>
      
      {/* Props Debug (only show if there are props) */}
      {Object.keys(props).length > 0 && (
        <div style={{ 
          marginTop: 24,
          padding: 12,
          background: '#f9fafb',
          borderRadius: 6,
          fontFamily: 'monospace',
          fontSize: 11
        }}>
          <div style={{ 
            fontSize: 10, 
            color: '#6b7280',
            marginBottom: 8,
            textTransform: 'uppercase',
            letterSpacing: '0.05em'
          }}>
            Props
          </div>
          <pre style={{ margin: 0, whiteSpace: 'pre-wrap' }}>
            {JSON.stringify(props, null, 2)}
          </pre>
        </div>
      )}
      
      {/* Route Params Debug */}
      {story.routeParams && Object.keys(story.routeParams).length > 0 && pageRoute && (
        <div style={{ 
          marginTop: 12,
          padding: 12,
          background: '#f0fdf4',
          borderRadius: 6,
          fontFamily: 'monospace',
          fontSize: 11,
          border: '1px solid #bbf7d0'
        }}>
          <div style={{ 
            fontSize: 10, 
            color: '#166534',
            marginBottom: 8,
            textTransform: 'uppercase',
            letterSpacing: '0.05em'
          }}>
            Route Params (via MemoryRouter)
          </div>
          <div style={{ marginBottom: 4, color: '#166534' }}>
            Route: {pageRoute} → {buildRouteUrl(pageRoute, story.routeParams)}
          </div>
          <div style={{ display: 'flex', flexWrap: 'wrap', gap: 4 }}>
            {Object.entries(story.routeParams).map(([key, value], i) => (
              <span key={i} style={{
                padding: '2px 8px',
                background: '#bbf7d0',
                color: '#166534',
                borderRadius: 4,
                fontSize: 11
              }}>
                :{key} = "{value}"
              </span>
            ))}
          </div>
        </div>
      )}
      
      {/* Mocked APIs Debug */}
      {story.mockApi && Object.keys(story.mockApi).length > 0 && (
        <div style={{ 
          marginTop: 12,
          padding: 12,
          background: '#fffbeb',
          borderRadius: 6,
          fontFamily: 'monospace',
          fontSize: 11,
          border: '1px solid #fef3c7'
        }}>
          <div style={{ 
            fontSize: 10, 
            color: '#92400e',
            marginBottom: 8,
            textTransform: 'uppercase',
            letterSpacing: '0.05em'
          }}>
            Mocked APIs
          </div>
          <div style={{ display: 'flex', flexWrap: 'wrap', gap: 4 }}>
            {Object.keys(story.mockApi).map((endpoint, i) => (
              <span key={i} style={{
                padding: '2px 8px',
                background: '#fef3c7',
                color: '#92400e',
                borderRadius: 4,
                fontSize: 11
              }}>
                {endpoint}
              </span>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
`;
}

// ==================== NEXT.JS APP ROUTER PREVIEW ====================

function generateNextJsPreviewComponent(components: ComponentInfo[], explorerPort: number): string {
  // Include all components except those that are clearly server-only
  // Components that fail to load will show an error in the preview UI
  const previewableComponents = components.filter(comp => {
    const fileName = comp.fileName.toLowerCase();
    // Exclude Next.js special files that are server-only
    if (fileName === 'page.tsx' || fileName === 'page.jsx') return false;
    if (fileName === 'layout.tsx' || fileName === 'layout.jsx') return false;
    if (fileName === 'loading.tsx' || fileName === 'loading.jsx') return false;
    if (fileName === 'error.tsx' || fileName === 'error.jsx') return false;
    if (fileName === 'not-found.tsx' || fileName === 'not-found.jsx') return false;
    if (fileName === 'route.ts' || fileName === 'route.js') return false;
    // Exclude if file path suggests it's an API route
    if (comp.filePath.includes('/app/') && comp.filePath.includes('/api/')) return false;
    return true;
  });

  log.info(`Including ${previewableComponents.length} of ${components.length} components in preview registry`);

  // Generate import statements
  const imports = previewableComponents.map((comp) => {
    const importPath = comp.filePath
      .replace(/\.(tsx?|jsx?)$/, '')
      .replace(/.*\/src\//, '@/')
      .replace(/.*\/app\//, '@/app/')
      .replace(/.*\/components\//, '@/components/');

    return `  '${comp.name}': () => import('${importPath}'),`;
  }).join('\n');

  return `/**
 * Component Preview - Auto-generated by Explorer
 * 
 * This file enables isolated component preview with mock data.
 * DO NOT EDIT - This file is managed by the Explorer tool.
 */
'use client';

import React, { useState, useEffect, Suspense, createContext, useContext, type ReactNode } from 'react';
import { useSearchParams } from 'next/navigation';
import { useParams as useNextParams } from 'next/navigation';

// ==================== MOCK PARAMS CONTEXT ====================
// For Next.js, we can't easily inject into useParams, so we provide a context
// that wraps the component and the component can optionally use
interface MockParamsContextValue {
  params: Record<string, string>;
  isPreview: boolean;
}

const MockParamsContext = createContext<MockParamsContextValue>({ params: {}, isPreview: false });

// Custom useParams hook that checks for mock params first
// Components can import this instead of next/navigation's useParams for preview compatibility
export function usePreviewParams<T extends Record<string, string> = Record<string, string>>(): T {
  const mockContext = useContext(MockParamsContext);
  const nextParams = useNextParams();
  
  // In preview mode with mock params, use those
  if (mockContext.isPreview && Object.keys(mockContext.params).length > 0) {
    return mockContext.params as T;
  }
  
  // Otherwise use real Next.js params
  return (nextParams || {}) as T;
}

// Provider component for mock params
function MockParamsProvider({ params, children }: { params: Record<string, string>; children: ReactNode }) {
  return (
    <MockParamsContext.Provider value={{ params, isPreview: true }}>
      {children}
    </MockParamsContext.Provider>
  );
}

// ==================== COMPONENT REGISTRY ====================
const componentRegistry: Record<string, () => Promise<any>> = {
${imports}
};

// ==================== FETCH MOCKING ====================
interface MockApiConfig {
  [endpoint: string]: any;
}

let originalFetch: typeof fetch;
let mockApiConfig: MockApiConfig = {};

// Convert route pattern to regex for flexible matching
// e.g., "/api/projects/:id" matches "/api/projects/123" and "/api/projects/undefined"
function createPatternMatcher(pattern: string): RegExp {
  // Escape special regex chars except :param patterns
  // Chain individual replacements to avoid character class parsing issues
  const escaped = pattern
    .replace(/\\\\/g, '\\\\\\\\')
    .replace(/\\./g, '\\\\.')
    .replace(/\\*/g, '\\\\*')
    .replace(/\\+/g, '\\\\+')
    .replace(/\\?/g, '\\\\?')
    .replace(/\\^/g, '\\\\^')
    .replace(/\\$/g, '\\\\$')
    .replace(/\\{/g, '\\\\{')
    .replace(/\\}/g, '\\\\}')
    .replace(/\\(/g, '\\\\(')
    .replace(/\\)/g, '\\\\)')
    .replace(/\\|/g, '\\\\|');
  // Convert :param to match any path segment (including "undefined")
  const regexPattern = escaped.replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, '([^/]+)');
  return new RegExp(regexPattern);
}

function setupFetchMocking(mockApi: MockApiConfig) {
  mockApiConfig = mockApi;
  
  if (!originalFetch) {
    originalFetch = window.fetch;
  }
  
  window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
    const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
    const method = init?.method?.toUpperCase() || 'GET';
    
    for (const [endpoint, mockData] of Object.entries(mockApiConfig)) {
      const [mockMethod, mockPath] = endpoint.includes(' ') 
        ? endpoint.split(' ') 
        : ['GET', endpoint];
      
      // Try exact match first
      if (url.includes(mockPath) && method === mockMethod.toUpperCase()) {
        console.log('[Canvas] Mocking API (exact):', method, url, '→', mockData);
        return createMockResponse(mockData);
      }
      
      // Try pattern matching (for routes with :params)
      if (mockPath.includes(':')) {
        const pattern = createPatternMatcher(mockPath);
        if (pattern.test(url) && method === mockMethod.toUpperCase()) {
          console.log('[Canvas] Mocking API (pattern):', method, url, 'matched', mockPath, '→', mockData);
          return createMockResponse(mockData);
        }
      }
    }
    
    return originalFetch(input, init);
  };
}

function createMockResponse(mockData: any): Response {
  if (mockData?.__delay) {
    return new Promise(() => {}) as any;
  }
  
  if (mockData?.__error) {
    return new Response(JSON.stringify(mockData.__error), {
      status: mockData.__error.status || 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  return new Response(JSON.stringify(mockData), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
}

function cleanupFetchMocking() {
  if (originalFetch) {
    window.fetch = originalFetch;
  }
  mockApiConfig = {};
}

// ==================== STORY FETCHING ====================
interface Story {
  id: string;
  name: string;
  description?: string;
  props?: Record<string, any>;
  routeParams?: Record<string, string>;
  queryParams?: Record<string, string>;
  mockApi?: MockApiConfig;
}

interface StoriesFile {
  pageName?: string;
  pagePath?: string;
  pageRoute?: string;
  stories: Story[];
}

async function fetchStoryData(
  type: 'component' | 'page',
  name: string,
  storyId: string
): Promise<{ story: Story | null; error: string | null }> {
  try {
    const response = await fetch(
      \`http://localhost:${explorerPort}/api/stories/\${type}/\${encodeURIComponent(name)}\`
    );
    
    if (!response.ok) {
      return { story: null, error: 'No stories found' };
    }
    
    const storiesFile: StoriesFile = await response.json();
    const story = storiesFile.stories.find(s => s.id === storyId) || storiesFile.stories[0];
    
    return { story, error: null };
  } catch (error) {
    return { story: null, error: 'Failed to connect to Explorer server' };
  }
}

// ==================== DYNAMIC COMPONENT LOADER ====================
// Helper to convert string to PascalCase
function toPascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Helper to normalize names (removes hyphens/underscores, lowercases)
// This handles kebab-case filenames matching PascalCase imports
function normalizeForMatch(str: string): string {
  return str.replace(/[-_]/g, '').toLowerCase();
}

// Find component loader by trying multiple naming strategies
function findComponentLoader(name: string): (() => Promise<any>) | undefined {
  // Try direct match first
  if (componentRegistry[name]) return componentRegistry[name];
  
  // Try lowercase
  const lowerName = name.toLowerCase();
  if (componentRegistry[lowerName]) return componentRegistry[lowerName];
  
  // Try PascalCase
  const pascalName = toPascalCase(name);
  if (componentRegistry[pascalName]) return componentRegistry[pascalName];
  
  // Try normalized match (handles kebab-case <-> PascalCase)
  const normalizedSearch = normalizeForMatch(name);
  for (const [key, loader] of Object.entries(componentRegistry)) {
    if (normalizeForMatch(key) === normalizedSearch) {
      return loader;
    }
  }
  
  return undefined;
}

interface DynamicComponentProps {
  componentName: string;
  props: Record<string, any>;
  routeParams?: Record<string, string>;
}

function DynamicComponent({ componentName, props, routeParams }: DynamicComponentProps) {
  const [Component, setComponent] = useState<React.ComponentType<any> | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadComponent = async () => {
      const loader = findComponentLoader(componentName);
      
      if (!loader) {
        setError(\`Component "\${componentName}" not found in registry. Available: \${Object.keys(componentRegistry).join(', ')}\`);
        return;
      }
      
      try {
        const module = await loader();
        // Try multiple variations: exact name, PascalCase, default, lowercase
        const pascalName = toPascalCase(componentName);
        const lowerName = componentName.toLowerCase();
        const Comp = module[componentName] || module[pascalName] || module[lowerName] || module.default;
        
        if (!Comp) {
          console.error('[PREVIEW] Available exports:', Object.keys(module));
          setError(\`Component "\${componentName}" not exported. Available: \${Object.keys(module).join(', ')}\`);
          return;
        }
        
        console.log('[PREVIEW] Loaded component:', pascalName || componentName);
        setComponent(() => Comp);
      } catch (err) {
        setError(\`Failed to load component: \${err}\`);
      }
    };
    
    loadComponent();
  }, [componentName]);

  if (error) {
    return <div style={{ padding: 20, color: 'red' }}>{error}</div>;
  }

  if (!Component) {
    return <div style={{ padding: 20 }}>Loading component...</div>;
  }

  // If we have route params, wrap with MockParamsProvider
  // This allows components using usePreviewParams to get the mock values
  const hasRouteParams = routeParams && Object.keys(routeParams).length > 0;
  
  if (hasRouteParams) {
    console.log('[PREVIEW] Wrapping with mock params:', routeParams);
    return (
      <MockParamsProvider params={routeParams!}>
        <Component {...props} />
      </MockParamsProvider>
    );
  }

  return <Component {...props} />;
}

// ==================== MAIN PREVIEW COMPONENT ====================
// Inner component that uses useSearchParams (requires Suspense boundary in Next.js 13+)
function CanvasPageInner() {
  const searchParams = useSearchParams();
  const componentName = searchParams.get('component') || '';
  const pageName = searchParams.get('page') || '';
  const storyId = searchParams.get('story') || 'default';
  
  // Determine if we're previewing a component or page
  const isPage = !!pageName;
  const itemName = pageName || componentName;
  const itemType = isPage ? 'page' : 'component';
  
  const [story, setStory] = useState<Story | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadStory = async () => {
      setLoading(true);
      
      if (!itemName) {
        setError('No component or page specified. Use ?component=Name or ?page=Name');
        setLoading(false);
        return;
      }
      
      console.log('[Canvas] Loading', { itemType, itemName, storyId });
      
      const { story: fetchedStory, error: fetchError } = await fetchStoryData(
        itemType,
        itemName,
        storyId
      );
      
      if (fetchError) {
        setError(fetchError);
        setLoading(false);
        return;
      }
      
      if (fetchedStory) {
        setStory(fetchedStory);
        if (fetchedStory.mockApi && Object.keys(fetchedStory.mockApi).length > 0) {
          console.log('[Canvas] Setting up fetch mocking for:', Object.keys(fetchedStory.mockApi));
          setupFetchMocking(fetchedStory.mockApi);
        }
      }
      
      setLoading(false);
    };
    
    loadStory();
    return () => cleanupFetchMocking();
  }, [itemName, itemType, storyId]);

  if (loading) {
    return (
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100vh' }}>
        Loading {itemType}: {itemName}...
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ padding: 20 }}>
        <div style={{ padding: 16, background: '#fef2f2', border: '1px solid #fecaca', borderRadius: 8 }}>
          <strong>Preview Error:</strong> {error}
        </div>
      </div>
    );
  }

  if (!story) {
    return (
      <div style={{ padding: 20 }}>
        <div style={{ padding: 16, background: '#fefce8', border: '1px solid #fef08a', borderRadius: 8 }}>
          No story found for this {itemType}. Generate stories using the Explorer.
        </div>
      </div>
    );
  }

  return (
    <div style={{ padding: 20 }}>
      <div style={{ marginBottom: 16, paddingBottom: 16, borderBottom: '1px solid #e5e7eb' }}>
        <div style={{ fontSize: 12, color: '#6b7280' }}>
          <span style={{ 
            padding: '2px 6px', 
            background: isPage ? '#dbeafe' : '#f3e8ff',
            color: isPage ? '#1d4ed8' : '#7c3aed',
            borderRadius: 4,
            fontSize: 10,
            marginRight: 8,
            textTransform: 'uppercase'
          }}>
            {itemType}
          </span>
          {itemName}
        </div>
        <div style={{ fontSize: 16, fontWeight: 600 }}>{story.name}</div>
        {story.description && (
          <div style={{ fontSize: 13, color: '#6b7280', marginTop: 4 }}>{story.description}</div>
        )}
      </div>
      
      <Suspense fallback={<div>Loading...</div>}>
        <DynamicComponent 
          componentName={itemName} 
          props={story.props || {}} 
          routeParams={story.routeParams}
        />
      </Suspense>
      
      {/* Mocked APIs Debug */}
      {story.mockApi && Object.keys(story.mockApi).length > 0 && (
        <div style={{ 
          marginTop: 12,
          padding: 12,
          background: '#fffbeb',
          borderRadius: 6,
          fontFamily: 'monospace',
          fontSize: 11,
          border: '1px solid #fef3c7'
        }}>
          <div style={{ fontSize: 10, color: '#92400e', marginBottom: 8, textTransform: 'uppercase' }}>
            Mocked APIs
          </div>
          <div style={{ display: 'flex', flexWrap: 'wrap', gap: 4 }}>
            {Object.keys(story.mockApi).map((endpoint, i) => (
              <span key={i} style={{ padding: '2px 8px', background: '#fef3c7', color: '#92400e', borderRadius: 4, fontSize: 11 }}>
                {endpoint}
              </span>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

// Wrapper component with Suspense boundary (required for useSearchParams in Next.js 13+)
export default function CanvasPage() {
  return (
    <Suspense fallback={
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100vh', fontFamily: 'system-ui' }}>
        Loading preview...
      </div>
    }>
      <CanvasPageInner />
    </Suspense>
  );
}
`;
}

// ==================== SETUP FUNCTIONS ====================

export interface SetupResult {
  success: boolean;
  message: string;
  filesCreated: string[];
  filesModified: string[];
  previewUrl: string;
}

export async function setupPreview(
  projectPath: string,
  routerType: RouterType,
  components: ComponentInfo[],
  explorerPort: number = 3050
): Promise<SetupResult> {
  log.info('Setting up preview', { projectPath, routerType, componentCount: components.length });
  
  const filesCreated: string[] = [];
  const filesModified: string[] = [];
  
  try {
    if (routerType === 'react-router' || routerType === 'unknown') {
      // Vite + React Router setup (default for unknown projects)
      if (routerType === 'unknown') {
        log.warn('Unknown router type, defaulting to React Router setup');
      }
      return await setupReactRouterPreview(projectPath, components, explorerPort, filesCreated, filesModified);
    } else if (routerType === 'nextjs-app') {
      // Next.js App Router setup
      return await setupNextJsAppPreview(projectPath, components, explorerPort, filesCreated, filesModified);
    } else if (routerType === 'nextjs-pages') {
      // Next.js Pages Router setup
      return await setupNextJsPagesPreview(projectPath, components, explorerPort, filesCreated, filesModified);
    } else {
      // Fallback to React Router
      log.warn('Unrecognized router type, defaulting to React Router setup', { routerType });
      return await setupReactRouterPreview(projectPath, components, explorerPort, filesCreated, filesModified);
    }
  } catch (error) {
    log.error('Preview setup failed', error);
    return {
      success: false,
      message: `Failed to setup preview: ${error}`,
      filesCreated: [],
      filesModified: [],
      previewUrl: ''
    };
  }
}

async function setupReactRouterPreview(
  projectPath: string,
  components: ComponentInfo[],
  explorerPort: number,
  filesCreated: string[],
  filesModified: string[]
): Promise<SetupResult> {
  // Create the Canvas preview component
  const previewContent = generatePreviewComponent(components, explorerPort);
  const previewPath = path.join(projectPath, 'src', '__Canvas.tsx');
  
  await fs.mkdir(path.dirname(previewPath), { recursive: true });
  await fs.writeFile(previewPath, previewContent, 'utf-8');
  filesCreated.push('src/__Canvas.tsx');
  log.success('Created Canvas component', { path: previewPath });
  
  // Check if App.tsx exists and add route
  const appPath = path.join(projectPath, 'src', 'App.tsx');
  try {
    let appContent = await fs.readFile(appPath, 'utf-8');
    
    // Check if preview route already exists
    if (!appContent.includes('__Canvas')) {
      // Add import
      const importStatement = `import Canvas from './__Canvas';\n`;
      
      // Find the first import and add after it
      const firstImportMatch = appContent.match(/^import .+$/m);
      if (firstImportMatch) {
        appContent = appContent.replace(
          firstImportMatch[0],
          firstImportMatch[0] + '\n' + importStatement
        );
      }
      
      // Add route - look for Routes component
      const routeToAdd = `        <Route path="/storial-preview" element={<Canvas />} />\n`;
      
      // Find <Routes> and add the preview route as the first route
      const routesMatch = appContent.match(/<Routes[^>]*>/);
      if (routesMatch) {
        appContent = appContent.replace(
          routesMatch[0],
          routesMatch[0] + '\n' + routeToAdd
        );
        
        await fs.writeFile(appPath, appContent, 'utf-8');
        filesModified.push('src/App.tsx');
        log.success('Added preview route to App.tsx');
      } else {
        log.warn('Could not find <Routes> in App.tsx - manual route addition required');
      }
    } else {
      log.info('Preview route already exists in App.tsx');
    }
  } catch (error) {
    log.warn('Could not modify App.tsx', error);
  }
  
  return {
    success: true,
    message: 'Preview setup complete for React Router project',
    filesCreated,
    filesModified,
    previewUrl: '/storial-preview'
  };
}

async function setupNextJsAppPreview(
  projectPath: string,
  components: ComponentInfo[],
  explorerPort: number,
  filesCreated: string[],
  filesModified: string[]
): Promise<SetupResult> {
  // Use the app/ directory for preview - accept that root layout will be inherited
  // This is the most reliable approach:
  // - Next.js 16+ forbids pages/ at root when app/ is in src/
  // - Turbopack has issues with mixed src/app and src/pages
  // - The preview will include the app's navbar/layout - this is acceptable

  // Determine if using src/ or direct app/
  const hasSrc = await fs.access(path.join(projectPath, 'src', 'app')).then(() => true).catch(() => false);
  const appDir = hasSrc ? path.join(projectPath, 'src', 'app') : path.join(projectPath, 'app');

  // Create storial-preview directory
  const previewDir = path.join(appDir, 'storial-preview');
  await fs.mkdir(previewDir, { recursive: true });
  log.info('Using app/storial-preview/ directory for preview', { previewDir });

  // Create storial-preview/page.tsx (no layout.tsx - we accept root layout inheritance)
  const previewPath = path.join(previewDir, 'page.tsx');
  const previewContent = generateNextJsPreviewComponent(components, explorerPort);
  await fs.writeFile(previewPath, previewContent, 'utf-8');

  const pageRelativePath = hasSrc ? 'src/app/storial-preview/page.tsx' : 'app/storial-preview/page.tsx';
  filesCreated.push(pageRelativePath);
  log.success('Created Next.js preview page', { path: previewPath });

  return {
    success: true,
    message: 'Preview setup complete for Next.js App Router project',
    filesCreated,
    filesModified,
    previewUrl: '/storial-preview'
  };
}

async function setupNextJsPagesPreview(
  projectPath: string,
  components: ComponentInfo[],
  explorerPort: number,
  filesCreated: string[],
  filesModified: string[]
): Promise<SetupResult> {
  // Create pages/storial-preview.tsx
  const hasSrc = await fs.access(path.join(projectPath, 'src', 'pages')).then(() => true).catch(() => false);
  const pagesDir = hasSrc ? path.join(projectPath, 'src', 'pages') : path.join(projectPath, 'pages');

  const previewPath = path.join(pagesDir, 'storial-preview.tsx');
  const previewContent = generateNextJsPreviewComponent(components, explorerPort);
  
  await fs.writeFile(previewPath, previewContent, 'utf-8');
  
  const relativePath = hasSrc ? 'src/pages/storial-preview.tsx' : 'pages/storial-preview.tsx';
  filesCreated.push(relativePath);
  log.success('Created Next.js preview page', { path: previewPath });

  return {
    success: true,
    message: 'Preview setup complete for Next.js Pages Router project',
    filesCreated,
    filesModified,
    previewUrl: '/storial-preview'
  };
}

// ==================== STATUS CHECK ====================

export interface PreviewStatus {
  isSetup: boolean;
  previewFileExists: boolean;
  routeExists: boolean;
  previewFilePath: string | null;
}

export async function checkPreviewStatus(
  projectPath: string,
  routerType: RouterType
): Promise<PreviewStatus> {
  log.info('Checking preview status', { projectPath, routerType });
  
  const result: PreviewStatus = {
    isSetup: false,
    previewFileExists: false,
    routeExists: false,
    previewFilePath: null
  };
  
  try {
    let previewPath: string;
    
    if (routerType === 'react-router' || routerType === 'unknown') {
      // Default to React Router path for unknown types
      previewPath = path.join(projectPath, 'src', '__Canvas.tsx');
    } else if (routerType === 'nextjs-app') {
      const hasSrc = await fs.access(path.join(projectPath, 'src', 'app')).then(() => true).catch(() => false);
      previewPath = hasSrc
        ? path.join(projectPath, 'src', 'app', 'storial-preview', 'page.tsx')
        : path.join(projectPath, 'app', 'storial-preview', 'page.tsx');
    } else {
      const hasSrc = await fs.access(path.join(projectPath, 'src', 'pages')).then(() => true).catch(() => false);
      previewPath = hasSrc
        ? path.join(projectPath, 'src', 'pages', 'storial-preview.tsx')
        : path.join(projectPath, 'pages', 'storial-preview.tsx');
    }
    
    // Check if preview file exists
    try {
      await fs.access(previewPath);
      result.previewFileExists = true;
      result.previewFilePath = previewPath;
      result.routeExists = true; // If file exists, route exists
      result.isSetup = true;
      log.success('Preview is set up', { path: previewPath });
    } catch {
      log.info('Preview not set up');
    }
  } catch (error) {
    log.error('Error checking preview status', error);
  }
  
  return result;
}

// ==================== CLEANUP ====================

export async function removePreview(
  projectPath: string,
  routerType: RouterType
): Promise<{ success: boolean; message: string }> {
  log.info('Removing preview', { projectPath, routerType });
  
  try {
    if (routerType === 'react-router' || routerType === 'unknown') {
      // Remove Canvas component (default to React Router path for unknown)
      const previewPath = path.join(projectPath, 'src', '__Canvas.tsx');
      await fs.unlink(previewPath).catch(() => {});
      
      // Remove route from App.tsx
      const appPath = path.join(projectPath, 'src', 'App.tsx');
      try {
        let appContent = await fs.readFile(appPath, 'utf-8');
        appContent = appContent.replace(/import Canvas from '.\/__Canvas';\n/g, '');
        appContent = appContent.replace(/\s*<Route path="\/storial-preview" element={<Canvas \/>} \/>\n/g, '');
        await fs.writeFile(appPath, appContent, 'utf-8');
      } catch {}
      
    } else if (routerType === 'nextjs-app') {
      const hasSrc = await fs.access(path.join(projectPath, 'src', 'app')).then(() => true).catch(() => false);
      const previewDir = hasSrc
        ? path.join(projectPath, 'src', 'app', 'storial-preview')
        : path.join(projectPath, 'app', 'storial-preview');
      await fs.rm(previewDir, { recursive: true }).catch(() => {});

    } else {
      const hasSrc = await fs.access(path.join(projectPath, 'src', 'pages')).then(() => true).catch(() => false);
      const previewPath = hasSrc
        ? path.join(projectPath, 'src', 'pages', 'storial-preview.tsx')
        : path.join(projectPath, 'pages', 'storial-preview.tsx');
      await fs.unlink(previewPath).catch(() => {});
    }
    
    log.success('Preview removed');
    return { success: true, message: 'Preview removed successfully' };
  } catch (error) {
    log.error('Failed to remove preview', error);
    return { success: false, message: `Failed to remove preview: ${error}` };
  }
}

